import os
import requests
import logging
import time
import datetime
import pytz
import random
import json
from utils import format_error_for_display
from models import Post
from app import db

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Environment configuration
TELEGRAM_TOKEN = os.environ.get('TELEGRAM_TOKEN')
# Check and correct CHANNEL_ID format
_channel_id = os.environ.get('CHANNEL_ID', '@tradepotrest')
# Remove Cyrillic characters that may cause problems
import re
_channel_id = re.sub(r'[^a-zA-Z0-9_@]', '', _channel_id)
# Add @ if it's not at the beginning
if _channel_id and not _channel_id.startswith('@'):
    _channel_id = '@' + _channel_id
CHANNEL_ID = _channel_id
OPENROUTER_API_KEY = os.environ.get('OPENROUTER_API_KEY')

# Constants
MAX_RETRIES = 3
RETRY_DELAY = 5  # seconds
TIMEZONE = pytz.timezone('Asia/Dushanbe')

# Post history is stored in database, this is only for temporary caching
post_history = []

# Trading topic suggestions
TRADING_TOPICS = [
    "üî• –°–µ–∫—Ä–µ—Ç—ã —É—Å–ø–µ—à–Ω–æ–≥–æ —Å–∫–∞–ª—å–ø–∏–Ω–≥–∞ –Ω–∞ –≤–∞–ª—é—Ç–Ω–æ–º —Ä—ã–Ω–∫–µ: –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–µ —Å–¥–µ–ª–∫–∏ –∏ –≤—ã—Å–æ–∫–∞—è –ø—Ä–∏–±—ã–ª—å",
    "üìà –°–≤–∏–Ω–≥-—Ç—Ä–µ–π–¥–∏–Ω–≥ –Ω–∞ —Ñ–æ–Ω–¥–æ–≤–æ–º —Ä—ã–Ω–∫–µ: –∫–∞–∫ –ø–æ–π–º–∞—Ç—å –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–π —Ç—Ä–µ–Ω–¥ –∏ –∑–∞—Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏",
    "üí∞ –ü–∞—Å—Å–∏–≤–Ω—ã–π –¥–æ—Ö–æ–¥: —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤ –¥–∏–≤–∏–¥–µ–Ω–¥–Ω—ã–µ –∞–∫—Ü–∏–∏ —Å –≤—ã—Å–æ–∫–æ–π –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç—å—é",
    "üöÄ –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–Ω–∞—è —Ä–µ–≤–æ–ª—é—Ü–∏—è: –∫–∞–∫ –∑–∞—Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞ —Ç–æ—Ä–≥–æ–≤–ª–µ Bitcoin –∏ –∞–ª—å—Ç–∫–æ–∏–Ω–∞–º–∏ –≤ 2025 –≥–æ–¥—É",
    "üìä –ú–∞—Å—Ç–µ—Ä—Å—Ç–≤–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞: –∫–∞–∫ –±–µ–∑–æ—à–∏–±–æ—á–Ω–æ —á–∏—Ç–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫–∏ –∏ –ø—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è —Ä—ã–Ω–∫–∞",
    "‚ö†Ô∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∏—Å–∫–∞–º–∏: –∫–ª—é—á–µ–≤–æ–π —Ñ–∞–∫—Ç–æ—Ä –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–≥–æ —É—Å–ø–µ—Ö–∞ –≤ —Ç—Ä–µ–π–¥–∏–Ω–≥–µ –∏ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏—è—Ö",
    "üß† –ü—Å–∏—Ö–æ–ª–æ–≥–∏—è –ø–æ–±–µ–¥–∏—Ç–µ–ª—è: –∫–∞–∫ –ø—Ä–µ–æ–¥–æ–ª–µ—Ç—å —Å—Ç—Ä–∞—Ö –∏ –∂–∞–¥–Ω–æ—Å—Ç—å –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Å—Ç–∞–±–∏–ª—å–Ω–æ–π –ø—Ä–∏–±—ã–ª–∏",
    "üîç –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑: –∏—Å–∫—É—Å—Å—Ç–≤–æ –≤—ã–±–æ—Ä–∞ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã—Ö –∫–æ–º–ø–∞–Ω–∏–π –∏ –∞–∫—Ç–∏–≤–æ–≤ –ø–µ—Ä–µ–¥ —Ä–æ—Å—Ç–æ–º",
    "‚ö° –¢–æ—Ä–≥–æ–≤–ª—è —Ñ—å—é—á–µ—Ä—Å–∞–º–∏: —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —Å –≤—ã—Å–æ–∫–∏–º –ª–µ–≤–µ—Ä–∏–¥–∂–µ–º –¥–ª—è –æ–ø—ã—Ç–Ω—ã—Ö —Ç—Ä–µ–π–¥–µ—Ä–æ–≤",
    "üõ°Ô∏è –û–ø—Ü–∏–æ–Ω–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: –∫–∞–∫ –∑–∞—â–∏—Ç–∏—Ç—å —Å–≤–æ–π –ø–æ—Ä—Ç—Ñ–µ–ª—å –∏ –ø–æ–ª—É—á–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –¥–æ—Ö–æ–¥",
    "üíé –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–≥–æ –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤ –±–∏—Ç–∫–æ–∏–Ω: –æ—Ç –ø–æ–∫—É–ø–∫–∏ –¥–æ —Å—Ç–µ–π–∫–∏–Ω–≥–∞ –∏ DeFi",
    "üîÆ –¢–æ–ø-10 –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–µ–Ω –∑–Ω–∞—Ç—å –∫–∞–∂–¥—ã–π —É—Å–ø–µ—à–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä",
    "üè¢ –£—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è: —Ç–æ—á–∫–∏ –≤—Ö–æ–¥–∞ –∏ –≤—ã—Ö–æ–¥–∞ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–∏–±—ã–ª–∏",
    "üß© –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞: –æ—Ç –ø—Ä–æ—Å—Ç–æ–≥–æ –∫ —Å–ª–æ–∂–Ω–æ–º—É",
    "üõ¢Ô∏è –ò–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ –≤ —Å—ã—Ä—å–µ–≤—ã–µ —Ç–æ–≤–∞—Ä—ã: –∫–∞–∫ –¥–∏–≤–µ—Ä—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—å –∏ –∑–∞—â–∏—Ç–∏—Ç—å –∫–∞–ø–∏—Ç–∞–ª –æ—Ç –∏–Ω—Ñ–ª—è—Ü–∏–∏",
    "üíº –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω–æ–≥–æ –ø–æ—Ä—Ç—Ñ–µ–ª—è: –∞–∫—Ü–∏–∏, –æ–±–ª–∏–≥–∞—Ü–∏–∏, ETF –∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∞–∫—Ç–∏–≤—ã",
    "üì± –ú–æ–±–∏–ª—å–Ω—ã–π —Ç—Ä–µ–π–¥–∏–Ω–≥: –ª—É—á—à–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏ —Å —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –≤ –ª—é–±–æ–π —Ç–æ—á–∫–µ –º–∏—Ä–∞",
    "üò± –°–∞–º—ã–µ –æ–ø–∞—Å–Ω—ã–µ –æ—à–∏–±–∫–∏ –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö —Ç—Ä–µ–π–¥–µ—Ä–æ–≤ –∏ –∫–∞–∫ –∏—Ö –∏–∑–±–µ–∂–∞—Ç—å: —á–µ—Å—Ç–Ω—ã–π –≤–∑–≥–ª—è–¥ –Ω–∞ —Ä–∏—Å–∫–∏",
    "ü§ñ –ê–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–∞—è —Ç–æ—Ä–≥–æ–≤–ª—è –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤: –ø–µ—Ä–≤—ã–µ —à–∞–≥–∏ –∫ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –≤–∞—à–∏—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π",
    "üí™ –û—Ç –Ω–æ–≤–∏—á–∫–∞ –∫ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—É: –∏—Å—Ç–æ—Ä–∏—è —É—Å–ø–µ—Ö–∞ —Ç—Ä–µ–π–¥–µ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–≤—Ä–∞—Ç–∏–ª $1000 –≤ –º–∏–ª–ª–∏–æ–Ω",
    "üåä –¢–æ—Ä–≥–æ–≤–ª—è –Ω–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏: –∫–∞–∫ –∏–∑–≤–ª–µ—á—å –ø—Ä–∏–±—ã–ª—å –≤ –ø–µ—Ä–∏–æ–¥—ã –ø–∞–Ω–∏–∫–∏ –∏ —ç–π—Ñ–æ—Ä–∏–∏ –Ω–∞ —Ä—ã–Ω–∫–µ",
    "üì∞ –ö–∞–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ –¥–ª—è –ø—Ä–∏–Ω—è—Ç–∏—è –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ä–µ—à–µ–Ω–∏–π",
    "üîã –≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π —Å–µ–∫—Ç–æ—Ä: –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–π –≤ —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—É—é –∏ –≤–æ–∑–æ–±–Ω–æ–≤–ª—è–µ–º—É—é —ç–Ω–µ—Ä–≥–µ—Ç–∏–∫—É",
    "üè¶ –ë–∞–Ω–∫–æ–≤—Å–∫–∏–π —Å–µ–∫—Ç–æ—Ä: –∞–Ω–∞–ª–∏–∑ –∞–∫—Ü–∏–π —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö –∫–æ–º–ø–∞–Ω–∏–π –¥–ª—è –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–≥–æ —Ä–æ—Å—Ç–∞ –∫–∞–ø–∏—Ç–∞–ª–∞",
    "üßò‚Äç‚ôÇÔ∏è –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç —Ç—Ä–µ–π–¥–µ—Ä–∞: –∫–∞–∫ —É–ø—Ä–∞–≤–ª—è—Ç—å —Å—Ç—Ä–µ—Å—Å–æ–º –∏ –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ä–∞—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è"
]

def generate_post_text(prompt=None):
    """Generate text content using OpenRouter's GPT-4 or Claude"""
    try:
        if not OPENROUTER_API_KEY:
            logger.error("OpenRouter API key is not set")
            # Create diverse fallback text based on the topic
            fallback_texts = [
                "üöÄ –¢—Ä–µ–π–¥–∏–Ω–≥ - —ç—Ç–æ –∏—Å–∫—É—Å—Å—Ç–≤–æ –±–∞–ª–∞–Ω—Å–∞ –∏ —Ç–µ—Ä–ø–µ–Ω–∏—è! –ö–∞–∂–¥–∞—è —Å–¥–µ–ª–∫–∞ —É—á–∏—Ç –Ω–∞—Å —á–µ–º—É-—Ç–æ –Ω–æ–≤–æ–º—É. –ü–æ–º–Ω–∏—Ç–µ: –≤ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–π –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–µ –≤—ã–∏–≥—Ä—ã–≤–∞—é—Ç –¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ. #—Ç—Ä–µ–π–¥–∏–Ω–≥ #–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ #tradepo",
                "üíπ –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —Ä—ã–Ω–∫–∏ –Ω–µ –ø—Ä–æ—â–∞—é—Ç —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π. –£—Å–ø–µ—à–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä - —ç—Ç–æ —Ö–ª–∞–¥–Ω–æ–∫—Ä–æ–≤–Ω—ã–π —Å—Ç—Ä–∞—Ç–µ–≥ —Å —á–µ—Ç–∫–∏–º –ø–ª–∞–Ω–æ–º –¥–µ–π—Å—Ç–≤–∏–π! #–±–∏—Ä–∂–∞ #–∞–Ω–∞–ª–∏—Ç–∏–∫–∞ #tradepo",
                "üìä –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ - –≤–∞—à –ª—É—á—à–∏–π –¥—Ä—É–≥ –Ω–∞ —Ä—ã–Ω–∫–µ! –£—á–∏—Ç–µ—Å—å —á–∏—Ç–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫–∏ –∏ –≤–∏–¥–µ—Ç—å —Ç–æ, —á—Ç–æ –¥—Ä—É–≥–∏–µ —É–ø—É—Å–∫–∞—é—Ç –∏–∑ –≤–∏–¥—É. –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –≤ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ - –∫–ª—é—á –∫ —É—Å–ø–µ—Ö—É! #—Ç—Ä–µ–π–¥–∏–Ω–≥ #–≥—Ä–∞—Ñ–∏–∫–∏ #tradepo",
                "üí∞ –ò–Ω–≤–µ—Å—Ç–∏—Ä—É–π—Ç–µ –≤ —Å–≤–æ–∏ –∑–Ω–∞–Ω–∏—è –ø—Ä–µ–∂–¥–µ, —á–µ–º –≤–∫–ª–∞–¥—ã–≤–∞—Ç—å –¥–µ–Ω—å–≥–∏. –°–∞–º–æ–µ –≤—ã–≥–æ–¥–Ω–æ–µ –≤–ª–æ–∂–µ–Ω–∏–µ - –≤ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ! #–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ #—Å–∞–º–æ—Ä–∞–∑–≤–∏—Ç–∏–µ #tradepo",
                "‚ö° –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å - –Ω–µ –≤—Ä–∞–≥, –∞ –¥—Ä—É–≥ —Ç—Ä–µ–π–¥–µ—Ä–∞! –ò–º–µ–Ω–Ω–æ –≤ –ø–µ—Ä–∏–æ–¥—ã –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ —Ä–æ–∂–¥–∞—é—Ç—Å—è —Å–∞–º—ã–µ –ø—Ä–∏–±—ã–ª—å–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏. –ë—É–¥—å—Ç–µ –≥–æ—Ç–æ–≤—ã! #—Ç—Ä–µ–π–¥–∏–Ω–≥ #–ø—Ä–∏–±—ã–ª—å #tradepo",
                "üî• –î–∏—Å—Ü–∏–ø–ª–∏–Ω–∞ –∏ —Å—Ç—Ä–æ–≥–æ–µ —Å–æ–±–ª—é–¥–µ–Ω–∏–µ —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞ - –¥–≤–∞ —Å—Ç–æ–ª–ø–∞ —É—Å–ø–µ—à–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞. –ë–µ–∑ –Ω–∏—Ö –¥–∞–∂–µ –ª—É—á—à–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –æ–±—Ä–µ—á–µ–Ω–∞ –Ω–∞ –ø—Ä–æ–≤–∞–ª! #—Ç—Ä–µ–π–¥–∏–Ω–≥ #—Ä–∏—Å–∫–∏ #tradepo"
            ]
            
            # Choose text based on prompt
            if prompt:
                # Use simple hash function to select text based on prompt
                index = sum(ord(c) for c in prompt) % len(fallback_texts)
                return fallback_texts[index]
            else:
                return random.choice(fallback_texts)
            
        headers = {
            "HTTP-Referer": "https://replit.com",  # Add referer for OpenRouter
            "X-Title": "TRADEPO Bot",
            "Authorization": f"Bearer {OPENROUTER_API_KEY}",
            "Content-Type": "application/json"
        }
        
        # Expand prompt to make it more substantial
        user_prompt = prompt
        # Add context to request for diverse content
        current_time = datetime.datetime.now()
        content_request = f"–ù–∞–ø–∏—à–∏ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π –∏ –ø–æ–¥—Ä–æ–±–Ω—ã–π –ø–æ—Å—Ç –æ —Ç—Ä–µ–π–¥–∏–Ω–≥–µ –Ω–∞ —Ç–µ–º—É: {user_prompt}"
        content_request += "\n\n–î–æ–±–∞–≤—å –Ω–µ–æ—á–µ–≤–∏–¥–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ –∏ –ø–æ–ª–µ–∑–Ω—ã–µ —Å–æ–≤–µ—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Å—Ç–∏–ª—å —Å —ç–º–æ–¥–∂–∏."
        content_request += "\n\n–í–∫–ª—é—á–∏ —Ö—ç—à—Ç–µ–≥–∏ #—Ç—Ä–µ–π–¥–∏–Ω–≥ #–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ #—Ñ–∏–Ω–∞–Ω—Å—ã #tradepo –≤ –∫–æ–Ω—Ü–µ –ø–æ—Å—Ç–∞."
        content_request += f"\n\n–°–æ–∑–¥–∞–π —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç, –Ω–µ –ø–æ—Ö–æ–∂–∏–π –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –ø–æ—Å—Ç—ã. –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞: {current_time.strftime('%d.%m.%Y')}."
            
        data = {
            "model": "anthropic/claude-3-haiku",  # Use more accessible model
            "messages": [
                {"role": "system", "content": "–¢—ã - –æ–ø—ã—Ç–Ω—ã–π —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–π –∞–Ω–∞–ª–∏—Ç–∏–∫ –∏ —ç–∫—Å–ø–µ—Ä—Ç –ø–æ —Ç—Ä–µ–π–¥–∏–Ω–≥—É. –¢–≤–æ–π —Å—Ç–∏–ª—å –ø–∏—Å—å–º–∞ - –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏ –ø–æ–ª–µ–∑–Ω—ã–π. –°–æ–∑–¥–∞–≤–∞–π —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç."},
                {"role": "user", "content": content_request}
            ],
            "max_tokens": 250,  # Increase for more detailed content
            "temperature": 0.9  # Increase for more variety
        }
        
        for attempt in range(MAX_RETRIES):
            try:
                logger.info(f"Generating text, attempt {attempt+1}")
                response = requests.post(
                    "https://openrouter.ai/api/v1/chat/completions", 
                    headers=headers, 
                    json=data,
                    timeout=30
                )
                response.raise_for_status()
                
                # More robust response handling
                response_data = response.json()
                logger.debug(f"API response: {response_data}")
                
                # Check response format
                if 'choices' in response_data and len(response_data['choices']) > 0:
                    if 'message' in response_data['choices'][0] and 'content' in response_data['choices'][0]['message']:
                        text = response_data['choices'][0]['message']['content']
                    else:
                        # Fallback if structure is different
                        logger.warning("Unexpected response structure (no message/content)")
                        if 'text' in response_data:
                            text = response_data['text']
                        else:
                            raise KeyError("No recognizable text content in response")
                elif 'error' in response_data:
                    # Handle API error
                    error_message = response_data.get('error', {}).get('message', 'Unknown API error')
                    logger.error(f"API error: {error_message}")
                    raise KeyError(f"API error: {error_message}")
                else:
                    # If no choices field, use fallback
                    logger.warning("No 'choices' field in response, trying fallback extraction")
                    # Try to get text from arbitrary field
                    if 'output' in response_data:
                        text = response_data['output']
                    elif 'generated_text' in response_data:
                        text = response_data['generated_text']
                    else:
                        raise KeyError("Could not extract text from response")
                
                # Remove any markdown syntax that might be present
                text = text.replace('```', '').strip()
                
                logger.info(f"Generated text: {text[:50]}...")
                return text
                
            except Exception as e:
                logger.error(f"Error in text generation attempt {attempt+1}: {e}")
                if attempt < MAX_RETRIES - 1:
                    time.sleep(RETRY_DELAY)
                else:
                    # If all retries failed, return error
                    raise Exception(f"Failed to generate text after {MAX_RETRIES} attempts: {str(e)}")
                    
    except Exception as e:
        logger.error(f"Error in generate_post_text: {e}")
        # Return simple fallback text
        return f"üìä –í–∞–∂–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö —Ç—Ä–µ–π–¥–µ—Ä–æ–≤: –∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Ä—ã–Ω–æ–∫ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥–æ–π —Å–¥–µ–ª–∫–æ–π –∏ —Å–ª–µ–¥—É–π—Ç–µ —Å–≤–æ–µ–º—É —Ç–æ—Ä–≥–æ–≤–æ–º—É –ø–ª–∞–Ω—É. –£—Å–ø–µ—à–Ω—ã–π —Ç—Ä–µ–π–¥–∏–Ω–≥ —Å—Ç—Ä–æ–∏—Ç—Å—è –Ω–∞ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω–µ! #{prompt.replace(' ', '')} #—Ç—Ä–µ–π–¥–∏–Ω–≥ #tradepo"

def get_image_url():
    """Get a random image URL from the image_urls.txt file"""
    try:
        if os.path.exists('image_urls.txt'):
            with open('image_urls.txt', 'r', encoding='utf-8') as f:
                urls = [line.strip() for line in f.readlines() if line.strip()]
                
            if urls:
                return random.choice(urls)
                
    except Exception as e:
        logger.error(f"Error getting image URL: {e}")
        
    # Default image if none available
    return None

def send_telegram_message(text, image_url=None):
    """Send message to Telegram channel"""
    if not TELEGRAM_TOKEN:
        logger.error("Telegram token is not set")
        return False, "Telegram token is not set"
        
    if not CHANNEL_ID:
        logger.error("Channel ID is not set")
        return False, "Channel ID is not set"
        
    try:
        api_url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/"
        
        if image_url:
            # Send photo with caption
            endpoint = api_url + "sendPhoto"
            data = {
                "chat_id": CHANNEL_ID,
                "photo": image_url,
                "caption": text,
                "parse_mode": "HTML"
            }
        else:
            # Send text message
            endpoint = api_url + "sendMessage"
            data = {
                "chat_id": CHANNEL_ID,
                "text": text,
                "parse_mode": "HTML"
            }
            
        for attempt in range(MAX_RETRIES):
            try:
                logger.info(f"Sending message to Telegram, attempt {attempt+1}")
                response = requests.post(endpoint, data=data, timeout=30)
                response.raise_for_status()
                
                response_data = response.json()
                logger.debug(f"Telegram API response: {response_data}")
                
                if response_data.get('ok', False):
                    message_id = response_data.get('result', {}).get('message_id', None)
                    logger.info(f"Message sent successfully, message_id: {message_id}")
                    return True, message_id
                else:
                    error_description = response_data.get('description', 'Unknown error')
                    logger.error(f"Telegram API error: {error_description}")
                    return False, error_description
                    
            except Exception as e:
                logger.error(f"Error in send attempt {attempt+1}: {e}")
                if attempt < MAX_RETRIES - 1:
                    time.sleep(RETRY_DELAY)
                else:
                    # If all retries failed
                    return False, f"Failed to send message after {MAX_RETRIES} attempts: {str(e)}"
                    
    except Exception as e:
        logger.error(f"Error in send_telegram_message: {e}")
        return False, str(e)

def create_and_send_post(theme):
    """Create and send a post to the Telegram channel"""
    start_time = time.time()
    success = False
    text = None
    image_url = None
    result = None
    error = None
    
    try:
        logger.info(f"Creating post with theme: {theme}")
        
        # Generate text for the post
        text = generate_post_text(theme)
        
        # Get random image URL
        image_url = get_image_url()
        
        # Send message to Telegram
        success, result = send_telegram_message(text, image_url)
        
        # Calculate processing time
        processing_time = f"{time.time() - start_time:.2f}s"
        
        # Save post to database
        try:
            # Create a snippet for display
            text_snippet = text[:200] + "..." if text and len(text) > 200 else text
            
            # Create new post record
            post = Post(
                theme=theme,
                text_snippet=text_snippet,
                full_text=text,
                image_url=image_url,
                success=success,
                message_id=result if success else None,
                error=result if not success else None,
                processing_time=processing_time
            )
            
            # Add to database
            db.session.add(post)
            db.session.commit()
            
            # Add to in-memory cache
            post_dict = post.to_dict()
            post_history.insert(0, post_dict)
            
            # Keep only last 100 posts in memory
            if len(post_history) > 100:
                post_history.pop()
                
            logger.info(f"Post saved to database with ID: {post.id}")
            
        except Exception as db_error:
            logger.error(f"Error saving post to database: {db_error}")
            error = f"Database error: {str(db_error)}"
            
        return success, text, image_url, result
        
    except Exception as e:
        logger.error(f"Error in create_and_send_post: {e}")
        error_message = format_error_for_display(e)
        
        # Try to save error to database
        try:
            processing_time = f"{time.time() - start_time:.2f}s"
            
            post = Post(
                theme=theme,
                text_snippet=text[:200] + "..." if text and len(text) > 200 else text,
                full_text=text,
                image_url=image_url,
                success=False,
                error=error_message,
                processing_time=processing_time
            )
            
            db.session.add(post)
            db.session.commit()
            
            post_dict = post.to_dict()
            post_history.insert(0, post_dict)
            
            if len(post_history) > 100:
                post_history.pop()
                
        except Exception as db_error:
            logger.error(f"Error saving error to database: {db_error}")
            
        return False, text, image_url, error_message

def get_post_history(limit=20):
    """Return post history from database
    Returns the most recent posts from the database, or in-memory history as fallback
    """
    try:
        # Try to get posts from database
        posts = Post.query.order_by(Post.timestamp.desc()).limit(limit).all()
        
        if posts:
            return [post.to_dict() for post in posts]
        
        # If no posts in database, use in-memory history
        return post_history[:limit] if post_history else []
        
    except Exception as e:
        logger.error(f"Error getting post history: {e}")
        # Fallback to in-memory history on database error
        return post_history[:limit] if post_history else []

def get_random_topic():
    """Get a random topic for post generation that wasn't used recently"""
    try:
        # Load custom topics if they exist
        custom_topics = []
        try:
            if os.path.exists('custom_topics.txt'):
                with open('custom_topics.txt', 'r', encoding='utf-8') as f:
                    custom_topics = [line.strip() for line in f.readlines() if line.strip()]
        except Exception as e:
            logger.error(f"Error loading custom topics: {e}")
        
        # Combine built-in and custom topics
        all_topics = TRADING_TOPICS + custom_topics
        
        # Get recent post themes to avoid repetition
        recent_posts = get_post_history(10)
        recent_themes = [post.get('theme') for post in recent_posts if post.get('theme')]
        
        # Filter out recently used topics
        available_topics = [topic for topic in all_topics if topic not in recent_themes]
        
        # If all topics were used recently, use the full list
        if not available_topics:
            available_topics = all_topics
        
        # Select a random topic
        selected_topic = random.choice(available_topics)
        logger.info(f"Selected random topic: {selected_topic}")
        
        return selected_topic
    
    except Exception as e:
        logger.error(f"Error getting random topic: {e}")
        # Fallback to simple random choice from built-in topics
        return random.choice(TRADING_TOPICS)